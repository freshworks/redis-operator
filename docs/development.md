# Development

## Folder structure

### Code folder structure

- **api**: definition of the RedisFailover CRD.
- **client**: autogenerated client to interact with redis-failovers.
- **cmd**: contains the starting point of the application.
- **log**: wrapper of logrus, created to be able to mock it.
- **metrics**: exposer of status of the failovers created.
- **mocks**: contains the mocked interfaces for testing the application.
- **operator**: the main logic. Manages the requests from k8s and creates/updates/deletes the pieces as needed.
- **service**: services/clients to interact with k8s and redises.
- **vendor**: vendored packages used by the application.

### Non-code folder structure

- **charts**: helm chart to deploy the operator.
- **docker**: Dockerfiles to generate redis-failover docker images.
- **example**: yaml files with spec of redis-failover.
- **hack**: scripts to generate the redis-failover api-client.
- **scripts**: scripts used to build and run the app.

## Make development commands

You can do the following commands with make:

- Build the development container.
  `make docker-build`
- Generate mocks.
  `make go-generate`
- Generate client
  `make update-codegen`
- Run tests.
  `make test`
- Build the executable file.
  `make build`
- Run the app.
  `make run`
- Access the docker instance with a shell.
  `make shell`
- Install dependencies
  `make get-deps`
- Update dependencies
  `make update-deps`
- Build the app image.
  `make image`

## Development Gotchas and Implementation Notes

### Kubernetes Pod Annotations Update Strategy

When implementing pod annotation updates in the operator, we discovered an important limitation with the Kubernetes PATCH operation:

**Issue**: Using `kubectl patch` or client-go `Patch()` to add annotations fails when the pod has no existing annotations (i.e., when `metadata.annotations` is `nil` or empty).

**Root Cause**: PATCH operations require the target field to exist. When a pod is created without annotations, the `metadata.annotations` field doesn't exist, causing PATCH to fail with errors like "field not found" or "invalid patch".

**Solution**: Use `kubectl annotate` equivalent or client-go `Update()` with a full pod object instead of PATCH. This approach:
- Fetches the complete pod object
- Modifies the annotations map (creating it if necessary)
- Performs a full update operation

**Implementation**: In `service/k8s/pod.go`, the `UpdatePodAnnotations` method uses:
```go
// Fetch complete pod
pod, err := p.client.CoreV1().Pods(namespace).Get(context.TODO(), podName, metav1.GetOptions{})
// Modify annotations
pod.Annotations = annotations  // This works even if annotations was nil
// Update the full pod
_, err = p.client.CoreV1().Pods(namespace).Update(context.TODO(), pod, metav1.UpdateOptions{})
```

**Key Takeaway**: When working with Kubernetes resources that may not have certain fields initialized, prefer GET-modify-UPDATE pattern over PATCH operations for reliability.
